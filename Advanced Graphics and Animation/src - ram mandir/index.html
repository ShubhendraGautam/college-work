<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>GLTF Viewer</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.module.js";
      import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/GLTFLoader.js";
    
      // Create a scene
      const scene = new THREE.Scene();
    
      // Create a camera
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 5;
    
      // Create a renderer
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
    
      // Create a directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff);
      directionalLight.position.set(0, 1, 1).normalize();
      scene.add(directionalLight);
    
      // Load the GLTF file
      const loader = new GLTFLoader();
      loader.load('ram-mandir.gltf', (gltf) => {
        const model = gltf.scene;
        model.scale.set(1.5, 1.5, 1.5); // Adjust the scale as needed
        scene.add(model);
      });
    
      // Keyboard controls
      const keyboard = { 
        left: 0, 
        right: 0, 
        forward: 0, 
        backward: 0,
        up: 0,
        down: 0,
        rotate: 0
      };
    
      function onKeyDown(event) {
        switch (event.key) {
          case 'ArrowLeft':
            keyboard.left = 1;
            break;
          case 'ArrowRight':
            keyboard.right = 1;
            break;
          case 'ArrowUp':
            keyboard.backward = 1;
            break;
          case 'ArrowDown':
            keyboard.forward = 1;
            break;
          case 'z':
            keyboard.up = 1;
            break;
          case 'x':
            keyboard.down = 1;
            break;
          case 'r':
            keyboard.rotate = 1;
            break;
        }
      }
    
      function onKeyUp(event) {
        switch (event.key) {
          case 'ArrowLeft':
            keyboard.left = 0;
            break;
          case 'ArrowRight':
            keyboard.right = 0;
            break;
          case 'ArrowUp':
            keyboard.backward = 0;
            break;
          case 'ArrowDown':
            keyboard.forward = 0;
            break;
          case 'z':
            keyboard.up = 0;
            break;
          case 'x':
            keyboard.down = 0;
            break;
          case 'r':
            keyboard.rotate = 0;
            break;
        }
      }

      // Touch controls
      let touchStartX = 0;
      let touchStartY = 0;
      let isPanning = false;
      let swipeStartX = 0;

      function handleTouchStart(event) {
        if (event.touches.length === 1) {
          touchStartX = event.touches[0].clientX;
          touchStartY = event.touches[0].clientY;
          swipeStartX = touchStartX;
          isPanning = true;
        }
      }

      function handleTouchMove(event) {
        if (event.touches.length === 1 && isPanning) {
          const deltaX = event.touches[0].clientX - touchStartX;
          const deltaY = event.touches[0].clientY - touchStartY;
          const sensitivity = 0.1; // Adjust sensitivity as needed

          // Pan
          camera.position.x -= deltaX * sensitivity;
          camera.position.y += deltaY * sensitivity;

          touchStartX = event.touches[0].clientX;
          touchStartY = event.touches[0].clientY;
        }
      }

      function handleTouchEnd(event) {
        isPanning = false;

        // Check for horizontal swipe for rotation
        const swipeEndX = event.changedTouches[0].clientX;
        const swipeDistance = swipeEndX - swipeStartX;
        const rotationSpeed = 0.02; // Adjust rotation speed as needed

        if (Math.abs(swipeDistance) > 50) { // Adjust threshold as needed
          keyboard.rotate = swipeDistance > 0 ? -1 : 1;
        } else {
          keyboard.rotate = 0;
        }
      }

      function handleTouch(event) {
        switch (event.type) {
          case 'touchstart':
            handleTouchStart(event);
            break;
          case 'touchmove':
            handleTouchMove(event);
            break;
          case 'touchend':
            handleTouchEnd(event);
            break;
        }
      }

      document.addEventListener('touchstart', handleTouch, false);
      document.addEventListener('touchmove', handleTouch, false);
      document.addEventListener('touchend', handleTouch, false);
    
      document.addEventListener('keydown', onKeyDown, false);
      document.addEventListener('keyup', onKeyUp, false);
    
      // Render the scene
      function animate() {
        requestAnimationFrame(animate);
    
        // Update camera position based on keyboard input
        const speed = 0.1;
        camera.position.x += (keyboard.right - keyboard.left) * speed;
        camera.position.y += (keyboard.up - keyboard.down) * speed;
        camera.position.z += (keyboard.forward - keyboard.backward) * speed;

        // Rotate the canvas
        const rotationSpeed = 0.02;
        scene.rotation.y += keyboard.rotate * rotationSpeed;
    
        renderer.render(scene, camera);
      }
    
      animate();
    </script>
  </body>
</html>
